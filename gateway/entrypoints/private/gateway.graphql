schema {
  query: Query
  mutation: Mutation
}

type Query {
  getAccessToken(input: GetAccessTokenInput): GetAccessTokenResponse
  getVerificationStatus(input: GetVerificationStatusInput): GetVerificationStatusResponse
  getApplicant(input: GetApplicantInput): GetApplicantResponse
  connectivityState(tryToConnect: Boolean): ConnectivityState
}

type GetAccessTokenResponse {
  accessToken: String
}

input GetAccessTokenInput {
  userId: String
}

type GetVerificationStatusResponse {
  status: VerificationStatus
}

enum VerificationStatus {
  PENDING
  SUCCESS
  CANCELLED
}

input GetVerificationStatusInput {
  externalUserId: String
}

type GetApplicantResponse {
  applicant: Applicant
}

type Applicant {
  id: String
  firstName: String
  lastName: String
  middleName: String
  dateOfBirth: String
  nationality: String
  countryOfBirth: String
  countryOfResidence: String
  reasonsForOpeningAnAccount: String
  accountWillBeUsedFor: String
  city: String
  street: String
  apartmentOrHouse: String
  postalCode: String
  sumsubId: String
  idDocument: IdDocument
  addressDocuments: [AddressDocument]
}

type IdDocument {
  type: DocumentType
  frontSide: Byte
  backSide: Byte
}

enum DocumentType {
  PASSPORT
  ID_CARD
  RESIDENCE_PERMIT
}

"The `Byte` scalar type represents byte value as a Buffer"
scalar Byte

type AddressDocument {
  file: Byte
}

input GetApplicantInput {
  query: GetApplicantRequest_Query_Input
}

input GetApplicantRequest_Query_Input {
  id: String
  externalId: String
}

enum ConnectivityState {
  IDLE
  CONNECTING
  READY
  TRANSIENT_FAILURE
  SHUTDOWN
}

type Mutation {
  verifyIdentity(input: VerifyIdentityInput): VerifyIdentityResponse
  verifyDocuments(input: VerifyDocumentsInput): VerifyDocumentsResponse
  verifyAddresses(input: VerifyAddressesInput): VerifyAddressesResponse
  createApplicant(input: CreateApplicantInput): CreateApplicantResponse
  updateAddress(input: UpdateAddressInput): UpdateAddressResponse
}

type VerifyIdentityResponse {
  success: Boolean
  error: String
  externalUserId: String
}

input VerifyIdentityInput {
  identity: VerifyIdentityRequest_Identity_Input
}

input VerifyIdentityRequest_Identity_Input {
  firstName: String
  lastName: String
  middleName: String
  dateOfBirth: String
  nationality: String
  countryOfBirth: String
  countryOfResidence: String
  reasonsForOpeningAnAccount: String
  accountWillBeUsedFor: String
  city: String
  street: String
  apartmentOrHouse: String
  postalCode: String
}

type VerifyDocumentsResponse {
  success: Boolean
  error: String
}

input VerifyDocumentsInput {
  applicantId: String
  document: IdDocument_Input
}

input IdDocument_Input {
  type: DocumentType
  frontSide: Byte
  backSide: Byte
}

type VerifyAddressesResponse {
  success: Boolean
  error: String
}

input VerifyAddressesInput {
  applicantId: String
  addresses: [AddressDocument_Input]
}

input AddressDocument_Input {
  file: Byte
}

type CreateApplicantResponse {
  id: String
}

input CreateApplicantInput {
  firstName: String
  lastName: String
  middleName: String
  dateOfBirth: String
  nationality: String
  countryOfBirth: String
  countryOfResidence: String
  reasonsForOpeningAnAccount: String
  accountWillBeUsedFor: String
  city: String
  street: String
  apartmentOrHouse: String
  postalCode: String
}

type UpdateAddressResponse {
  id: String
}

input UpdateAddressInput {
  id: String
  city: String
  apartmentOrHouse: String
  postalCode: String
}
